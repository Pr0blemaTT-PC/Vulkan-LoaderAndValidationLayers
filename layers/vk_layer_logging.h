/* Copyright (c) 2015-2017 The Khronos Group Inc.
 * Copyright (c) 2015-2017 Valve Corporation
 * Copyright (c) 2015-2017 LunarG, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Author: Courtney Goeltzenleuchter <courtney@LunarG.com>
 * Author: Tobin Ehlis <tobin@lunarg.com>
 * Author: Mark Young <marky@lunarg.com>
 *
 */

#ifndef LAYER_LOGGING_H
#define LAYER_LOGGING_H

#include "vk_loader_layer.h"
#include "vk_layer_config.h"
#include "vk_layer_data.h"
#include "vk_layer_table.h"
#include "vk_loader_platform.h"
#include "vulkan/vk_layer.h"
#include <cinttypes>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <unordered_map>
#include <vector>

// TODO: Could be autogenerated for the specific handles for extra type safety...
template <typename HANDLE_T>
static inline uint64_t HandleToUint64(HANDLE_T *h) {
    return reinterpret_cast<uint64_t>(h);
}

template <typename HANDLE_T>
uint64_t HandleToUint64(HANDLE_T h);

static inline uint64_t HandleToUint64(uint64_t h) { return h; }

typedef struct _debug_report_data {
    VkLayerDbgFunctionNode *debug_callback_list;
    VkLayerDbgFunctionNode *default_debug_callback_list;
    VkFlags active_flags;
    bool g_DEBUG_REPORT;
    bool g_DEBUG_UTILS;
} debug_report_data;

template debug_report_data *GetLayerDataPtr<debug_report_data>(void *data_key,
                                                               std::unordered_map<void *, debug_report_data *> &data_map);

// Forward Declarations
static inline bool debug_log_msg(const debug_report_data *debug_data, VkFlags msgFlags, VkDebugReportObjectTypeEXT objectType,
                                 uint64_t srcObject, size_t location, int32_t msgCode, const char *pLayerPrefix, const char *pMsg);

// Add a debug message callback node structure to the specified callback linked list
static inline void AddDebugCallbackNode(debug_report_data *debug_data, VkLayerDbgFunctionNode **list_head,
                                        VkLayerDbgFunctionNode *new_node) {
    new_node->pNext = *list_head;
    *list_head = new_node;
}

// Remove specified debug messager node structure from the specified linked list
static inline void RemoveDebugUtilsMessager(debug_report_data *debug_data, VkLayerDbgFunctionNode **list_head, VkDebugUtilsMessengerEXT messenger) {
    VkLayerDbgFunctionNode *cur_callback = *list_head;
    VkLayerDbgFunctionNode *prev_callback = cur_callback;
    bool matched = false;
    VkFlags local_flags = 0;

    while (cur_callback) {
        if (cur_callback->is_messenger &&cur_callback->messenger.messenger == messenger) {
            matched = true;
            prev_callback->pNext = cur_callback->pNext;
            if (*list_head == cur_callback) {
                *list_head = cur_callback->pNext;
            }
            debug_log_msg(debug_data, VK_DEBUG_REPORT_DEBUG_BIT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
                          reinterpret_cast<uint64_t &>(cur_callback->messenger.messenger), 0, 0, "DebugUtilsMessenger",
                          "Destroyed messenger\n");
        } else {
            matched = false;
            // Temporary, for now, convert to VK_EXT_debug_report flags
            if (cur_callback->messenger.messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) {
                local_flags |= VK_DEBUG_REPORT_ERROR_BIT_EXT;
            }
            if (cur_callback->messenger.messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
                if (cur_callback->messenger.messageType & VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) {
                    local_flags |= VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
                }
                local_flags |= VK_DEBUG_REPORT_WARNING_BIT_EXT;
            }
            if (cur_callback->messenger.messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) {
                local_flags |= VK_DEBUG_REPORT_INFORMATION_BIT_EXT;
            }
            if (cur_callback->messenger.messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) {
                local_flags |= VK_DEBUG_REPORT_DEBUG_BIT_EXT;
            }
        }
        prev_callback = cur_callback;
        cur_callback = cur_callback->pNext;
        if (matched) {
            free(prev_callback);
        }
    }
    debug_data->active_flags = local_flags;
}

// Remove specified debug message callback node structure from the specified callback linked list
static inline void RemoveDebugUtilsMessageCallback(debug_report_data *debug_data, VkLayerDbgFunctionNode **list_head,
                                              VkDebugReportCallbackEXT callback) {
    VkLayerDbgFunctionNode *cur_callback = *list_head;
    VkLayerDbgFunctionNode *prev_callback = cur_callback;
    bool matched = false;
    VkFlags local_flags = 0;

    while (cur_callback) {
        if (!cur_callback->is_messenger && cur_callback->report.msgCallback == callback) {
            matched = true;
            prev_callback->pNext = cur_callback->pNext;
            if (*list_head == cur_callback) {
                *list_head = cur_callback->pNext;
            }
            debug_log_msg(debug_data, VK_DEBUG_REPORT_DEBUG_BIT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
                          reinterpret_cast<uint64_t &>(cur_callback->report.msgCallback), 0, 0, "DebugReport",
                          "Destroyed callback\n");
        } else {
            matched = false;
            local_flags |= cur_callback->report.msgFlags;
        }
        prev_callback = cur_callback;
        cur_callback = cur_callback->pNext;
        if (matched) {
            free(prev_callback);
        }
    }
    debug_data->active_flags = local_flags;
}

// Removes all debug callback function nodes from the specified callback linked lists and frees their resources
static inline void RemoveAllMessageCallbacks(debug_report_data *debug_data, VkLayerDbgFunctionNode **list_head) {
    VkLayerDbgFunctionNode *current_callback = *list_head;
    VkLayerDbgFunctionNode *prev_callback = current_callback;

    while (current_callback) {
        prev_callback = current_callback->pNext;
        if (!current_callback->is_messenger) {
            debug_log_msg(debug_data, VK_DEBUG_REPORT_ERROR_BIT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
                          (uint64_t)current_callback->report.msgCallback, 0, 0, "DebugReport",
                          "Debug Report callbacks not removed before DestroyInstance");
        } else {
            debug_log_msg(debug_data, VK_DEBUG_REPORT_ERROR_BIT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
                          (uint64_t)current_callback->messenger.messenger, 0, 0, "Messenger",
                          "Debug messengers not removed before DestroyInstance");
        }
        free(current_callback);
        current_callback = prev_callback;
    }
    *list_head = NULL;
}

static inline void DebugReportFlagsToAnnotFlags(VkDebugReportFlagsEXT dr_flags, bool default_flag_is_spec,
                                  VkDebugUtilsMessageSeverityFlagBitsEXT *da_severity, VkDebugUtilsMessageTypeFlagsEXT *da_type) {
    bool type_set = false;
    *da_type = 0;

    if ((dr_flags & VK_DEBUG_REPORT_INFORMATION_BIT_EXT) != 0) {
        *da_severity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT;
        *da_type |= VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT;
        type_set = true;
    } else if ((dr_flags & (VK_DEBUG_REPORT_WARNING_BIT_EXT | VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT)) != 0) {
        *da_severity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT;
    } else if ((dr_flags & VK_DEBUG_REPORT_ERROR_BIT_EXT) != 0) {
        *da_severity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    } else if ((dr_flags & VK_DEBUG_REPORT_DEBUG_BIT_EXT) != 0) {
        *da_severity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
        *da_type |= VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT;
        type_set = true;
    }

    if ((dr_flags & VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT) != 0) {
        *da_type |= VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    } else if (!type_set) {
        if (default_flag_is_spec) {
            *da_type |= VK_DEBUG_UTILS_MESSAGE_TYPE_SPECIFICATION_BIT_EXT;
        } else {
            *da_type |= VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT;
        }
    }
}

static inline void DebugReportObjectToAnnotObject(VkDebugReportObjectTypeEXT dr_object_type, uint64_t object_handle,
                                    VkDebugUtilsObjectNameInfoEXT *da_object_name_info) {
    da_object_name_info->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
    da_object_name_info->pNext = NULL;
    da_object_name_info->objectHandle = (uint64_t)(uintptr_t)object_handle;
    da_object_name_info->pObjectName = NULL;

    switch (dr_object_type) {
        case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_INSTANCE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_PHYSICAL_DEVICE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DEVICE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_QUEUE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_SEMAPHORE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_COMMAND_BUFFER;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_FENCE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DEVICE_MEMORY;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_BUFFER;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_IMAGE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_EVENT;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_QUERY_POOL;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_BUFFER_VIEW;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_IMAGE_VIEW;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_SHADER_MODULE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_PIPELINE_CACHE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_PIPELINE_LAYOUT;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_RENDER_PASS;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_PIPELINE;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_SAMPLER;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DESCRIPTOR_POOL;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DESCRIPTOR_SET;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_FRAMEBUFFER;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_COMMAND_POOL;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_SURFACE_KHR;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_SWAPCHAIN_KHR;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DISPLAY_KHR;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DISPLAY_MODE_KHR;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_OBJECT_TABLE_NVX;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX;
            break;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT:
            da_object_name_info->objectType = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR;
            break;
        default:
            da_object_name_info->objectType = VK_OBJECT_TYPE_UNKNOWN;
            break;
    }
}

// Utility function to handle reporting
static inline bool debug_log_msg(const debug_report_data *debug_data, VkFlags msgFlags, VkDebugReportObjectTypeEXT objectType,
                                 uint64_t srcObject, size_t location, int32_t msgCode, const char *pLayerPrefix, const char *pMsg) {
    bool bail = false;
    VkLayerDbgFunctionNode *pTrav = NULL;

    if (debug_data->debug_callback_list != NULL) {
        pTrav = debug_data->debug_callback_list;
    } else {
        pTrav = debug_data->default_debug_callback_list;
    }

    VkDebugUtilsMessageSeverityFlagBitsEXT severity;
    VkDebugUtilsMessageTypeFlagsEXT types;
    VkDebugUtilsMessengerCallbackDataEXT callback_data;
    VkDebugUtilsObjectNameInfoEXT object_name;

    DebugReportFlagsToAnnotFlags(msgFlags, true, &severity, &types);
    DebugReportObjectToAnnotObject(objectType, srcObject, &object_name);

    callback_data.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
    callback_data.pNext = NULL;
    callback_data.flags = 0;
    callback_data.pMessageSource = pLayerPrefix;
    callback_data.messageNumber = msgCode;
    callback_data.pMessage = pMsg;
    callback_data.queueLabelCount = 0;
    callback_data.pQueueLabels = NULL;
    callback_data.cmdBufLabelCount = 0;
    callback_data.pCmdBufLabels = NULL;
    callback_data.objectCount = 1;
    callback_data.pObjects = &object_name;

    while (pTrav) {
        if (!pTrav->is_messenger && (pTrav->report.msgFlags & msgFlags) &&
            pTrav->report.pfnMsgCallback(msgFlags, objectType, srcObject, location, msgCode, pLayerPrefix, pMsg,
                                         pTrav->pUserData)) {
            bail = true;
        }
        if (pTrav->is_messenger && (pTrav->messenger.messageSeverity & severity) && (pTrav->messenger.messageType & types) &&
                   pTrav->messenger.pfnUserCallback(severity, types, &callback_data, pTrav->pUserData)) {
            bail = true;
        }
        pTrav = pTrav->pNext;
    }

    return bail;
}

static inline void DebugAnnotFlagsToReportFlags(VkDebugUtilsMessageSeverityFlagBitsEXT da_severity, VkDebugUtilsMessageTypeFlagsEXT da_type,
                                                VkDebugReportFlagsEXT *dr_flags) {
    *dr_flags = 0;

    if ((da_severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) != 0) {
        *dr_flags |= VK_DEBUG_REPORT_ERROR_BIT_EXT;
    } else if ((da_severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) != 0) {
        if ((da_type & VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) != 0) {
            *dr_flags |= VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
        } else {
            *dr_flags |= VK_DEBUG_REPORT_WARNING_BIT_EXT;
        }
    } else if ((da_severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) != 0) {
        *dr_flags |= VK_DEBUG_REPORT_INFORMATION_BIT_EXT;
    } else if ((da_severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) != 0) {
        *dr_flags |= VK_DEBUG_REPORT_DEBUG_BIT_EXT;
    }
}

static inline void DebugAnnotObjectToDebugReportObject(const VkDebugUtilsObjectNameInfoEXT *da_object_name_info,
                                                       VkDebugReportObjectTypeEXT *dr_object_type, uint64_t *dr_object_handle) {
    switch (da_object_name_info->objectType) {
        case VK_OBJECT_TYPE_INSTANCE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT;
            break;
        case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT;
            break;
        case VK_OBJECT_TYPE_DEVICE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT;
            break;
        case VK_OBJECT_TYPE_QUEUE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT;
            break;
        case VK_OBJECT_TYPE_SEMAPHORE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT;
            break;
        case VK_OBJECT_TYPE_COMMAND_BUFFER:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT;
            break;
        case VK_OBJECT_TYPE_FENCE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT;
            break;
        case VK_OBJECT_TYPE_DEVICE_MEMORY:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT;
            break;
        case VK_OBJECT_TYPE_BUFFER:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT;
            break;
        case VK_OBJECT_TYPE_IMAGE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT;
            break;
        case VK_OBJECT_TYPE_EVENT:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT;
            break;
        case VK_OBJECT_TYPE_QUERY_POOL:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT;
            break;
        case VK_OBJECT_TYPE_BUFFER_VIEW:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT;
            break;
        case VK_OBJECT_TYPE_IMAGE_VIEW:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT;
            break;
        case VK_OBJECT_TYPE_SHADER_MODULE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT;
            break;
        case VK_OBJECT_TYPE_PIPELINE_CACHE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT;
            break;
        case VK_OBJECT_TYPE_PIPELINE_LAYOUT:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT;
            break;
        case VK_OBJECT_TYPE_RENDER_PASS:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT;
            break;
        case VK_OBJECT_TYPE_PIPELINE:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT;
            break;
        case VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT;
            break;
        case VK_OBJECT_TYPE_SAMPLER:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT;
            break;
        case VK_OBJECT_TYPE_DESCRIPTOR_POOL:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT;
            break;
        case VK_OBJECT_TYPE_DESCRIPTOR_SET:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT;
            break;
        case VK_OBJECT_TYPE_FRAMEBUFFER:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT;
            break;
        case VK_OBJECT_TYPE_COMMAND_POOL:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT;
            break;
        case VK_OBJECT_TYPE_SURFACE_KHR:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT;
            break;
        case VK_OBJECT_TYPE_SWAPCHAIN_KHR:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT;
            break;
        case VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT;
            break;
        case VK_OBJECT_TYPE_DISPLAY_KHR:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT;
            break;
        case VK_OBJECT_TYPE_DISPLAY_MODE_KHR:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT;
            break;
        case VK_OBJECT_TYPE_OBJECT_TABLE_NVX:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT;
            break;
        case VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT;
            break;
        case VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT;
            break;
        default:
            *dr_object_type = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT;
            break;
    }

    *dr_object_handle = da_object_name_info->objectHandle;
}

static inline bool debug_messenger_log_msg(const debug_report_data *debug_data, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                           VkDebugUtilsMessageTypeFlagsEXT messageType,
                                           const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) {
    bool bail = false;
    VkLayerDbgFunctionNode *pTrav = NULL;

    if (debug_data->debug_callback_list != NULL) {
        pTrav = debug_data->debug_callback_list;
    } else {
        pTrav = debug_data->default_debug_callback_list;
    }

    VkDebugReportObjectTypeEXT object_type;
    VkDebugReportFlagsEXT object_flags = 0;
    uint64_t object_handle;

    DebugAnnotFlagsToReportFlags(messageSeverity, messageType, &object_flags);
    DebugAnnotObjectToDebugReportObject(pCallbackData->pObjects, &object_type, &object_handle);

    while (pTrav) {
        if (pTrav->is_messenger && (pTrav->messenger.messageSeverity & messageSeverity) &&
            (pTrav->messenger.messageType & messageType) &&
            pTrav->messenger.pfnUserCallback(messageSeverity, messageType, pCallbackData, pTrav->pUserData)) {
            bail = true;
        }
        if (!pTrav->is_messenger && pTrav->report.msgFlags & object_flags) {
            if (pTrav->report.pfnMsgCallback(object_flags, object_type, object_handle, 0, pCallbackData->messageNumber,
                                                pCallbackData->pMessageSource, pCallbackData->pMessage, pTrav->pUserData)) {
                bail = true;
            }
        }
        pTrav = pTrav->pNext;
    }

    return bail;
}

static inline debug_report_data *debug_utils_create_instance(
    VkLayerInstanceDispatchTable *table, VkInstance inst, uint32_t extension_count,
    const char *const *ppEnabledExtensions)  // layer or extension name to be enabled
{
    debug_report_data *debug_data = (debug_report_data *)malloc(sizeof(debug_report_data));
    if (!debug_data) return NULL;

    memset(debug_data, 0, sizeof(debug_report_data));
    for (uint32_t i = 0; i < extension_count; i++) {
        // TODO: Check other property fields
        if (strcmp(ppEnabledExtensions[i], VK_EXT_DEBUG_REPORT_EXTENSION_NAME) == 0) {
            debug_data->g_DEBUG_REPORT = true;
        } else if (strcmp(ppEnabledExtensions[i], VK_EXT_DEBUG_UTILS_EXTENSION_NAME) == 0) {
            debug_data->g_DEBUG_UTILS = true;
        }
    }
    return debug_data;
}

static inline void layer_debug_utils_destroy_instance(debug_report_data *debug_data) {
    if (debug_data) {
        RemoveAllMessageCallbacks(debug_data, &debug_data->default_debug_callback_list);
        RemoveAllMessageCallbacks(debug_data, &debug_data->debug_callback_list);
        free(debug_data);
    }
}

static inline debug_report_data *layer_debug_utils_create_device(debug_report_data *instance_debug_data, VkDevice device) {
    // DEBUG_REPORT shares data between Instance and Device,
    // so just return instance's data pointer
    return instance_debug_data;
}

static inline void layer_debug_utils_destroy_device(VkDevice device) {
    // Nothing to do since we're using instance data record
}

static inline void layer_destroy_messenger_callback(debug_report_data *debug_data, VkDebugUtilsMessengerEXT messenger,
                                                 const VkAllocationCallbacks *pAllocator) {
    RemoveDebugUtilsMessager(debug_data, &debug_data->debug_callback_list, messenger);
    RemoveDebugUtilsMessager(debug_data, &debug_data->default_debug_callback_list, messenger);
}

static inline VkResult layer_create_messenger_callback(debug_report_data *debug_data, bool default_callback,
                                                       const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo,
                                                       const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) {
    VkLayerDbgFunctionNode *pNewDbgFuncNode = (VkLayerDbgFunctionNode *)malloc(sizeof(VkLayerDbgFunctionNode));
    if (!pNewDbgFuncNode) return VK_ERROR_OUT_OF_HOST_MEMORY;
    memset(pNewDbgFuncNode, 0, sizeof(VkLayerDbgFunctionNode));
    pNewDbgFuncNode->is_messenger = true;

    // Handle of 0 is logging_callback so use allocated Node address as unique handle
    if (!(*pMessenger)) *pMessenger = (VkDebugUtilsMessengerEXT)pNewDbgFuncNode;
    pNewDbgFuncNode->messenger.messenger = *pMessenger;
    pNewDbgFuncNode->messenger.pfnUserCallback = pCreateInfo->pfnUserCallback;
    pNewDbgFuncNode->messenger.messageSeverity = pCreateInfo->messageSeverity;
    pNewDbgFuncNode->messenger.messageType = pCreateInfo->messageType;
    pNewDbgFuncNode->pUserData = pCreateInfo->pUserData;

    debug_data->active_flags = 0;
    if (pCreateInfo->messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) {
        debug_data->active_flags |= VK_DEBUG_REPORT_ERROR_BIT_EXT;
    }
    if (pCreateInfo->messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
        if (pCreateInfo->messageType & VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) {
            debug_data->active_flags |= VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
        }
        debug_data->active_flags |= VK_DEBUG_REPORT_WARNING_BIT_EXT;
    }
    if (pCreateInfo->messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) {
        debug_data->active_flags |= VK_DEBUG_REPORT_INFORMATION_BIT_EXT;
    }
    if (pCreateInfo->messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) {
        debug_data->active_flags |= VK_DEBUG_REPORT_DEBUG_BIT_EXT;
    }

    if (default_callback) {
        AddDebugCallbackNode(debug_data, &debug_data->default_debug_callback_list, pNewDbgFuncNode);
    } else {
        AddDebugCallbackNode(debug_data, &debug_data->debug_callback_list, pNewDbgFuncNode);
    }

    VkDebugUtilsMessengerCallbackDataEXT callback_data = {};
    VkDebugUtilsObjectNameInfoEXT blank_object = {};
    callback_data.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
    callback_data.pNext = NULL;
    callback_data.flags = 0;
    callback_data.pMessageSource = "DebugUtilsMessenger";
    callback_data.messageNumber = 0;
    callback_data.pMessage = "Added messenger";
    callback_data.queueLabelCount = 0;
    callback_data.pQueueLabels = NULL;
    callback_data.cmdBufLabelCount = 0;
    callback_data.pCmdBufLabels = NULL;
    callback_data.objectCount = 1;
    callback_data.pObjects = &blank_object;
    blank_object.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
    blank_object.pNext = NULL;
    blank_object.objectType = VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT;
    blank_object.objectHandle = HandleToUint64(*pMessenger);
    blank_object.pObjectName = NULL;
    debug_messenger_log_msg(debug_data, VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
                            VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT, &callback_data);
    return VK_SUCCESS;
}

static inline void layer_destroy_report_callback(debug_report_data *debug_data, VkDebugReportCallbackEXT callback,
                                                 const VkAllocationCallbacks *pAllocator) {
    RemoveDebugUtilsMessageCallback(debug_data, &debug_data->debug_callback_list, callback);
    RemoveDebugUtilsMessageCallback(debug_data, &debug_data->default_debug_callback_list, callback);
}

static inline VkResult layer_create_report_callback(debug_report_data *debug_data, bool default_callback,
                                                    const VkDebugReportCallbackCreateInfoEXT *pCreateInfo,
                                                    const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) {
    VkLayerDbgFunctionNode *pNewDbgFuncNode = (VkLayerDbgFunctionNode *)malloc(sizeof(VkLayerDbgFunctionNode));
    if (!pNewDbgFuncNode) return VK_ERROR_OUT_OF_HOST_MEMORY;
    memset(pNewDbgFuncNode, 0, sizeof(VkLayerDbgFunctionNode));
    pNewDbgFuncNode->is_messenger = false;

    // Handle of 0 is logging_callback so use allocated Node address as unique handle
    if (!(*pCallback)) *pCallback = (VkDebugReportCallbackEXT)pNewDbgFuncNode;
    pNewDbgFuncNode->report.msgCallback = *pCallback;
    pNewDbgFuncNode->report.pfnMsgCallback = pCreateInfo->pfnCallback;
    pNewDbgFuncNode->report.msgFlags = pCreateInfo->flags;
    pNewDbgFuncNode->pUserData = pCreateInfo->pUserData;

    if (default_callback) {
        AddDebugCallbackNode(debug_data, &debug_data->default_debug_callback_list, pNewDbgFuncNode);
        debug_data->active_flags |= pCreateInfo->flags;
    } else {
        AddDebugCallbackNode(debug_data, &debug_data->debug_callback_list, pNewDbgFuncNode);
        debug_data->active_flags = pCreateInfo->flags;
    }

    debug_log_msg(debug_data, VK_DEBUG_REPORT_DEBUG_BIT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT, (uint64_t)*pCallback, 0,
                  0, "DebugReport", "Added callback");
    return VK_SUCCESS;
}

static inline PFN_vkVoidFunction debug_utils_get_instance_proc_addr(debug_report_data *debug_data, const char *funcName) {
    if (!debug_data) {
        return NULL;
    }
    if (debug_data->g_DEBUG_REPORT) {
        if (!strcmp(funcName, "vkCreateDebugReportCallbackEXT")) {
            return (PFN_vkVoidFunction)vkCreateDebugReportCallbackEXT;
        }
        if (!strcmp(funcName, "vkDestroyDebugReportCallbackEXT")) {
            return (PFN_vkVoidFunction)vkDestroyDebugReportCallbackEXT;
        }
        if (!strcmp(funcName, "vkDebugReportMessageEXT")) {
            return (PFN_vkVoidFunction)vkDebugReportMessageEXT;
        }
    }
    if (debug_data->g_DEBUG_UTILS) {
        if (!strcmp(funcName, "vkCreateDebugUtilsMessengerEXT")) {
            return (PFN_vkVoidFunction)vkCreateDebugUtilsMessengerEXT;
        }
        if (!strcmp(funcName, "vkDestroyDebugUtilsMessengerEXT")) {
            return (PFN_vkVoidFunction)vkDestroyDebugUtilsMessengerEXT;
        }
        if (!strcmp(funcName, "vkSubmitDebugUtilsMessageEXT")) {
            return (PFN_vkVoidFunction)vkSubmitDebugUtilsMessageEXT;
        }
    }
    return NULL;
}

// This utility (called at vkCreateInstance() time), looks at a pNext chain.
// It counts any VkDebugReportCallbackCreateInfoEXT structs that it finds.  It
// then allocates an array that can hold that many structs, as well as that
// many VkDebugReportCallbackEXT handles.  It then copies each
// VkDebugReportCallbackCreateInfoEXT, and initializes each handle.
static VkResult layer_copy_tmp_report_callbacks(const void *pChain, uint32_t *num_callbacks,
                                                VkDebugReportCallbackCreateInfoEXT **infos, VkDebugReportCallbackEXT **callbacks) {
    uint32_t n = *num_callbacks = 0;

    const void *pNext = pChain;
    while (pNext) {
        // 1st, count the number VkDebugReportCallbackCreateInfoEXT:
        if (((VkDebugReportCallbackCreateInfoEXT *)pNext)->sType == VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT) {
            n++;
        }
        pNext = (void *)((VkDebugReportCallbackCreateInfoEXT *)pNext)->pNext;
    }
    if (n == 0) {
        return VK_SUCCESS;
    }

    // 2nd, allocate memory for each VkDebugReportCallbackCreateInfoEXT:
    VkDebugReportCallbackCreateInfoEXT *pInfos = *infos =
        ((VkDebugReportCallbackCreateInfoEXT *)malloc(n * sizeof(VkDebugReportCallbackCreateInfoEXT)));
    if (!pInfos) {
        return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
    // 3rd, allocate memory for a unique handle for each callback:
    VkDebugReportCallbackEXT *pCallbacks = *callbacks = ((VkDebugReportCallbackEXT *)malloc(n * sizeof(VkDebugReportCallbackEXT)));
    if (!pCallbacks) {
        free(pInfos);
        return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
    // 4th, copy each VkDebugReportCallbackCreateInfoEXT for use by
    // vkDestroyInstance, and assign a unique handle to each callback (just
    // use the address of the copied VkDebugReportCallbackCreateInfoEXT):
    pNext = pChain;
    while (pNext) {
        if (((VkInstanceCreateInfo *)pNext)->sType == VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT) {
            memcpy(pInfos, pNext, sizeof(VkDebugReportCallbackCreateInfoEXT));
            *pCallbacks++ = (VkDebugReportCallbackEXT)pInfos++;
        }
        pNext = (void *)((VkInstanceCreateInfo *)pNext)->pNext;
    }

    *num_callbacks = n;
    return VK_SUCCESS;
}

// This utility frees the arrays allocated by layer_copy_tmp_report_callbacks()
static void layer_free_tmp_report_callbacks(VkDebugReportCallbackCreateInfoEXT *infos, VkDebugReportCallbackEXT *callbacks) {
    free(infos);
    free(callbacks);
}

// This utility enables all of the VkDebugReportCallbackCreateInfoEXT structs
// that were copied by layer_copy_tmp_report_callbacks()
static VkResult layer_enable_tmp_report_callbacks(debug_report_data *debug_data, uint32_t num_callbacks,
                                                  VkDebugReportCallbackCreateInfoEXT *infos, VkDebugReportCallbackEXT *callbacks) {
    VkResult rtn = VK_SUCCESS;
    for (uint32_t i = 0; i < num_callbacks; i++) {
        rtn = layer_create_report_callback(debug_data, false, &infos[i], NULL, &callbacks[i]);
        if (rtn != VK_SUCCESS) {
            for (uint32_t j = 0; j < i; j++) {
                layer_destroy_report_callback(debug_data, callbacks[j], NULL);
            }
            return rtn;
        }
    }
    return rtn;
}

// This utility disables all of the VkDebugReportCallbackCreateInfoEXT structs
// that were copied by layer_copy_tmp_report_callbacks()
static void layer_disable_tmp_report_callbacks(debug_report_data *debug_data, uint32_t num_callbacks,
                                               VkDebugReportCallbackEXT *callbacks) {
    for (uint32_t i = 0; i < num_callbacks; i++) {
        layer_destroy_report_callback(debug_data, callbacks[i], NULL);
    }
}

// This utility (called at vkCreateInstance() time), looks at a pNext chain.
// It counts any VkDebugUtilsMessengerCreateInfoEXT structs that it finds.  It
// then allocates an array that can hold that many structs, as well as that
// many VkDebugUtilsMessengerEXT handles.  It then copies each
// VkDebugUtilsMessengerCreateInfoEXT, and initializes each handle.
static VkResult layer_copy_tmp_debug_messengers(const void *pChain, uint32_t *num_messengers, VkDebugUtilsMessengerCreateInfoEXT **infos,
                                                VkDebugUtilsMessengerEXT **messengers) {
    uint32_t n = *num_messengers = 0;

    const void *pNext = pChain;
    while (pNext) {
        // 1st, count the number VkDebugUtilsMessengerCreateInfoEXT:
        if (((VkDebugUtilsMessengerCreateInfoEXT *)pNext)->sType == VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT) {
            n++;
        }
        pNext = (void *)((VkDebugUtilsMessengerCreateInfoEXT *)pNext)->pNext;
    }
    if (n == 0) {
        return VK_SUCCESS;
    }

    // 2nd, allocate memory for each VkDebugUtilsMessengerCreateInfoEXT:
    VkDebugUtilsMessengerCreateInfoEXT *pInfos = *infos =
        ((VkDebugUtilsMessengerCreateInfoEXT *)malloc(n * sizeof(VkDebugUtilsMessengerCreateInfoEXT)));
    if (!pInfos) {
        return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
    // 3rd, allocate memory for a unique handle for each messenger:
    VkDebugUtilsMessengerEXT *pMessengers = *messengers = ((VkDebugUtilsMessengerEXT *)malloc(n * sizeof(VkDebugUtilsMessengerEXT)));
    if (!pMessengers) {
        free(pInfos);
        return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
    // 4th, copy each VkDebugUtilsMessengerCreateInfoEXT for use by
    // vkDestroyInstance, and assign a unique handle to each callback (just
    // use the address of the copied VkDebugUtilsMessengerCreateInfoEXT):
    pNext = pChain;
    while (pNext) {
        if (((VkInstanceCreateInfo *)pNext)->sType == VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT) {
            memcpy(pInfos, pNext, sizeof(VkDebugUtilsMessengerCreateInfoEXT));
            *pMessengers++ = (VkDebugUtilsMessengerEXT)pInfos++;
        }
        pNext = (void *)((VkInstanceCreateInfo *)pNext)->pNext;
    }

    *num_messengers = n;
    return VK_SUCCESS;
}

// This utility frees the arrays allocated by layer_copy_tmp_debug_messengers()
static void layer_free_tmp_debug_messengers(VkDebugUtilsMessengerCreateInfoEXT *infos, VkDebugUtilsMessengerEXT *messengers) {
    free(infos);
    free(messengers);
}

// This utility enables all of the VkDebugUtilsMessengerCreateInfoEXT structs
// that were copied by layer_copy_tmp_debug_messengers()
static VkResult layer_enable_tmp_debug_messengers(debug_report_data *debug_data, uint32_t num_messengers,
                                                  VkDebugUtilsMessengerCreateInfoEXT *infos, VkDebugUtilsMessengerEXT *messengers) {
    VkResult rtn = VK_SUCCESS;
    for (uint32_t i = 0; i < num_messengers; i++) {
        rtn = layer_create_messenger_callback(debug_data, false, &infos[i], NULL, &messengers[i]);
        if (rtn != VK_SUCCESS) {
            for (uint32_t j = 0; j < i; j++) {
                layer_destroy_messenger_callback(debug_data, messengers[j], NULL);
            }
            return rtn;
        }
    }
    return rtn;
}

// This utility disables all of the VkDebugUtilsMessengerCreateInfoEXT structs
// that were copied by layer_copy_tmp_debug_messengers()
static void layer_disable_tmp_debug_messengers(debug_report_data *debug_data, uint32_t num_messengers,
                                               VkDebugUtilsMessengerEXT *messengers) {
    for (uint32_t i = 0; i < num_messengers; i++) {
        layer_destroy_messenger_callback(debug_data, messengers[i], NULL);
    }
}

// Checks if the message will get logged.
// Allows layer to defer collecting & formating data if the
// message will be discarded.
static inline bool will_log_msg(debug_report_data *debug_data, VkFlags msgFlags) {
    if (!debug_data || !(debug_data->active_flags & msgFlags)) {
        // Message is not wanted
        return false;
    }

    return true;
}

#ifdef WIN32
static inline int vasprintf(char **strp, char const *fmt, va_list ap) {
    *strp = nullptr;
    int size = _vscprintf(fmt, ap);
    if (size >= 0) {
        *strp = (char *)malloc(size + 1);
        if (!*strp) {
            return -1;
        }
        _vsnprintf(*strp, size + 1, fmt, ap);
    }
    return size;
}
#endif

// Output log message via DEBUG_REPORT
// Takes format and variable arg list so that output string
// is only computed if a message needs to be logged
#ifndef WIN32
static inline bool log_msg(const debug_report_data *debug_data, VkFlags msgFlags, VkDebugReportObjectTypeEXT objectType,
                           uint64_t srcObject, size_t location, int32_t msgCode, const char *pLayerPrefix, const char *format, ...)
    __attribute__((format(printf, 8, 9)));
#endif
static inline bool log_msg(const debug_report_data *debug_data, VkFlags msgFlags, VkDebugReportObjectTypeEXT objectType,
                           uint64_t srcObject, size_t location, int32_t msgCode, const char *pLayerPrefix, const char *format,
                           ...) {
    if (!debug_data || !(debug_data->active_flags & msgFlags)) {
        // Message is not wanted
        return false;
    }

    va_list argptr;
    va_start(argptr, format);
    char *str;
    if (-1 == vasprintf(&str, format, argptr)) {
        // On failure, glibc vasprintf leaves str undefined
        str = nullptr;
    }
    va_end(argptr);
    bool result = debug_log_msg(debug_data, msgFlags, objectType, srcObject, location, msgCode, pLayerPrefix,
                                str ? str : "Allocation failure");
    free(str);
    return result;
}

static inline VKAPI_ATTR VkBool32 VKAPI_CALL report_log_callback(VkFlags msgFlags, VkDebugReportObjectTypeEXT objType,
                                                                 uint64_t srcObject, size_t location, int32_t msgCode,
                                                                 const char *pLayerPrefix, const char *pMsg, void *pUserData) {
    char msg_flags[30];

    print_msg_flags(msgFlags, msg_flags);

    fprintf((FILE *)pUserData, "%s(%s): object: 0x%" PRIx64 " type: %d location: %lu msgCode: %d: %s\n", pLayerPrefix, msg_flags,
            srcObject, objType, (unsigned long)location, msgCode, pMsg);
    fflush((FILE *)pUserData);

    return false;
}

static inline VKAPI_ATTR VkBool32 VKAPI_CALL report_win32_debug_output_msg(VkFlags msgFlags, VkDebugReportObjectTypeEXT objType,
                                                                           uint64_t srcObject, size_t location, int32_t msgCode,
                                                                           const char *pLayerPrefix, const char *pMsg,
                                                                           void *pUserData) {
#ifdef WIN32
    char msg_flags[30];
    char buf[2048];

    print_msg_flags(msgFlags, msg_flags);
    _snprintf(buf, sizeof(buf) - 1,
              "%s (%s): object: 0x%" PRIxPTR " type: %d location: " PRINTF_SIZE_T_SPECIFIER " msgCode: %d: %s\n", pLayerPrefix,
              msg_flags, (size_t)srcObject, objType, location, msgCode, pMsg);

    OutputDebugString(buf);
#endif

    return false;
}

static inline VKAPI_ATTR VkBool32 VKAPI_CALL messenger_log_callback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                                                    VkDebugUtilsMessageTypeFlagsEXT messageType,
                                                                    const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData,
                                                                    void *pUserData) {
    char msg_severity[30];
    char msg_type[30];

    print_msg_severity(messageSeverity, msg_severity);
    print_msg_type(messageType, msg_type);

    fprintf((FILE *)pUserData, "%s(%s / %s): object: 0x%" PRIx64 " type: %d msgNum: %d - %s\n", pCallbackData->pMessageSource,
            msg_severity, msg_type, pCallbackData->pObjects[0].objectHandle, pCallbackData->pObjects[0].objectType,
            pCallbackData->messageNumber, pCallbackData->pMessage);
    fflush((FILE *)pUserData);

    return false;
}

static inline VKAPI_ATTR VkBool32 VKAPI_CALL messenger_win32_debug_output_msg(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                                                              VkDebugUtilsMessageTypeFlagsEXT messageType,
                                                                              const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData,
                                                                              void *pUserData) {
#ifdef WIN32
    char buf[2048];
    char msg_severity[30];
    char msg_type[30];

    print_msg_severity(messageSeverity, msg_severity);
    print_msg_type(messageType, msg_type);

    _snprintf(buf, sizeof(buf) - 1, "%s (%s / %s): object: 0x%" PRIxPTR " type: %d  msgNum: %d - %s\n",
              pCallbackData->pMessageSource, msg_severity, msg_type, pCallbackData->pObjects[0].objectHandle,
              pCallbackData->pObjects[0].objectType, pCallbackData->messageNumber, pCallbackData->pMessage);

    OutputDebugString(buf);
#endif

    return false;
}

#endif  // LAYER_LOGGING_H
